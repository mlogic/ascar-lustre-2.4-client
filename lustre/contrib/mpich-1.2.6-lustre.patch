diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.c	2005-12-06 11:54:37.883130927 -0500
@@ -0,0 +1,37 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $
+ *
+ *   Copyright (C) 2001 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+/* adioi.h has the ADIOI_Fns_struct define */
+#include "adioi.h"
+
+struct ADIOI_Fns_struct ADIO_LUSTRE_operations = {
+    ADIOI_LUSTRE_Open, /* Open */
+    ADIOI_LUSTRE_ReadContig, /* ReadContig */
+    ADIOI_LUSTRE_WriteContig, /* WriteContig */
+    ADIOI_GEN_ReadStridedColl, /* ReadStridedColl */
+    ADIOI_GEN_WriteStridedColl, /* WriteStridedColl */
+    ADIOI_GEN_SeekIndividual, /* SeekIndividual */
+    ADIOI_LUSTRE_Fcntl, /* Fcntl */
+    ADIOI_LUSTRE_SetInfo, /* SetInfo */
+    ADIOI_GEN_ReadStrided, /* ReadStrided */
+    ADIOI_GEN_WriteStrided, /* WriteStrided */
+    ADIOI_LUSTRE_Close, /* Close */
+    ADIOI_LUSTRE_IreadContig, /* IreadContig */
+    ADIOI_LUSTRE_IwriteContig, /* IwriteContig */
+    ADIOI_LUSTRE_ReadDone, /* ReadDone */
+    ADIOI_LUSTRE_WriteDone, /* WriteDone */
+    ADIOI_LUSTRE_ReadComplete, /* ReadComplete */
+    ADIOI_LUSTRE_WriteComplete, /* WriteComplete */
+    ADIOI_LUSTRE_IreadStrided, /* IreadStrided */
+    ADIOI_LUSTRE_IwriteStrided, /* IwriteStrided */
+    ADIOI_GEN_Flush, /* Flush */
+    ADIOI_LUSTRE_Resize, /* Resize */
+    ADIOI_GEN_Delete, /* Delete */
+};
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_close.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_close.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_close.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_close.c	2005-12-06 11:54:37.895129327 -0500
@@ -0,0 +1,32 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_close.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_Close(ADIO_File fd, int *error_code)
+{
+    int err;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_CLOSE";
+#endif
+
+    err = close(fd->fd_sys);
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_done.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_done.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_done.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_done.c	2005-12-06 11:54:37.898128927 -0500
@@ -0,0 +1,188 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_done.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+int ADIOI_LUSTRE_ReadDone(ADIO_Request *request, ADIO_Status *status, int *error_code)  
+{
+#ifndef NO_AIO
+    int done=0;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_READDONE";
+#endif
+#ifdef AIO_SUN 
+    aio_result_t *result=0, *tmp;
+#else
+    int err;
+#endif
+#ifdef AIO_HANDLE_IN_AIOCB
+    struct aiocb *tmp1;
+#endif
+#endif
+
+    if (*request == ADIO_REQUEST_NULL) {
+	*error_code = MPI_SUCCESS;
+	return 1;
+    }
+
+#ifdef NO_AIO
+/* HP, FreeBSD, Linux */
+#ifdef HAVE_STATUS_SET_BYTES
+    MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+    (*request)->fd->async_count--;
+    ADIOI_Free_request((ADIOI_Req_node *) (*request));
+    *request = ADIO_REQUEST_NULL;
+    *error_code = MPI_SUCCESS;
+    return 1;
+#endif    
+
+#ifdef AIO_SUN
+    if ((*request)->queued) {
+	tmp = (aio_result_t *) (*request)->handle;
+	if (tmp->aio_return == AIO_INPROGRESS) {
+	    done = 0;
+	    *error_code = MPI_SUCCESS;
+	}
+	else if (tmp->aio_return != -1) {
+	    result = (aio_result_t *) aiowait(0); /* dequeue any one request */
+	    done = 1;
+	    (*request)->nbytes = tmp->aio_return;
+	    *error_code = MPI_SUCCESS;
+	}
+	else {
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		"**io %s", strerror(tmp->aio_errno));
+	    return;
+#elif defined(PRINT_ERR_MSG)
+	    *error_code = MPI_ERR_UNKNOWN;
+#else
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+		         myname, "I/O Error", "%s", strerror(tmp->aio_errno));
+	    ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	}
+    } /* if ((*request)->queued) ... */
+    else {
+	/* ADIOI_Complete_Async completed this request, but request object
+           was not freed. */
+	done = 1;
+	*error_code = MPI_SUCCESS;
+    }
+#ifdef HAVE_STATUS_SET_BYTES
+    if (done && ((*request)->nbytes != -1))
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+
+#endif
+
+#ifdef AIO_HANDLE_IN_AIOCB
+/* IBM */
+    if ((*request)->queued) {
+	tmp1 = (struct aiocb *) (*request)->handle;
+	errno = aio_error(tmp1->aio_handle);
+	if (errno == EINPROG) {
+	    done = 0;
+	    *error_code = MPI_SUCCESS;
+	}
+	else {
+	    err = aio_return(tmp1->aio_handle);
+	    (*request)->nbytes = err;
+	    errno = aio_error(tmp1->aio_handle);
+	
+	    done = 1;
+
+	    if (err == -1) {
+#ifdef MPICH2
+		*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		    "**io %s", strerror(errno));
+		return;
+#elif defined(PRINT_ERR_MSG)
+				*error_code = MPI_ERR_UNKNOWN;
+#else
+		*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+		ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	    }
+	    else *error_code = MPI_SUCCESS;
+	}
+    } /* if ((*request)->queued) */
+    else {
+	done = 1;
+	*error_code = MPI_SUCCESS;
+    }
+#ifdef HAVE_STATUS_SET_BYTES
+    if (done && ((*request)->nbytes != -1))
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+
+#elif (!defined(NO_AIO) && !defined(AIO_SUN))
+/* DEC, SGI IRIX 5 and 6 */
+    if ((*request)->queued) {
+	errno = aio_error((const struct aiocb *) (*request)->handle);
+	if (errno == EINPROGRESS) {
+	    done = 0;
+	    *error_code = MPI_SUCCESS;
+	}
+	else {
+	    err = aio_return((struct aiocb *) (*request)->handle); 
+	    (*request)->nbytes = err;
+	    errno = aio_error((struct aiocb *) (*request)->handle);
+
+	    done = 1;
+
+	    if (err == -1) {
+#ifdef MPICH2
+		*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		    "**io %s", strerror(errno));
+		return;
+#elif defined(PRINT_ERR_MSG)
+				*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+		*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+		ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	    }
+	    else *error_code = MPI_SUCCESS;
+	}
+    } /* if ((*request)->queued) */
+    else {
+	done = 1;
+	*error_code = MPI_SUCCESS;
+    }
+#ifdef HAVE_STATUS_SET_BYTES
+    if (done && ((*request)->nbytes != -1))
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+
+#endif
+
+#ifndef NO_AIO
+    if (done) {
+	/* if request is still queued in the system, it is also there
+           on ADIOI_Async_list. Delete it from there. */
+	if ((*request)->queued) ADIOI_Del_req_from_list(request);
+
+	(*request)->fd->async_count--;
+	if ((*request)->handle) ADIOI_Free((*request)->handle);
+	ADIOI_Free_request((ADIOI_Req_node *) (*request));
+	*request = ADIO_REQUEST_NULL;
+    }
+    return done;
+#endif
+
+}
+
+
+int ADIOI_LUSTRE_WriteDone(ADIO_Request *request, ADIO_Status *status, int *error_code)  
+{
+    return ADIOI_LUSTRE_ReadDone(request, status, error_code);
+} 
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_fcntl.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_fcntl.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_fcntl.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_fcntl.c	2005-12-06 11:54:37.901128527 -0500
@@ -0,0 +1,126 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_fcntl.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+#include "adio_extern.h"
+/* #ifdef MPISGI
+#include "mpisgi2.h"
+#endif */
+
+void ADIOI_LUSTRE_Fcntl(ADIO_File fd, int flag, ADIO_Fcntl_t *fcntl_struct, int *error_code)
+{
+    int i, ntimes;
+    ADIO_Offset curr_fsize, alloc_size, size, len, done;
+    ADIO_Status status;
+    char *buf;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_FCNTL";
+#endif
+
+    switch(flag) {
+    case ADIO_FCNTL_GET_FSIZE:
+	fcntl_struct->fsize = lseek(fd->fd_sys, 0, SEEK_END);
+	if (fd->fp_sys_posn != -1) 
+	     lseek(fd->fd_sys, fd->fp_sys_posn, SEEK_SET);
+	if (fcntl_struct->fsize == -1) {
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		"**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	    ADIOI_Error(fd, *error_code, myname);	    
+#endif
+	}
+	else *error_code = MPI_SUCCESS;
+	break;
+
+    case ADIO_FCNTL_SET_DISKSPACE:
+	/* will be called by one process only */
+	/* On file systems with no preallocation function, I have to 
+           explicitly write 
+           to allocate space. Since there could be holes in the file, 
+           I need to read up to the current file size, write it back, 
+           and then write beyond that depending on how much 
+           preallocation is needed.
+           read/write in sizes of no more than ADIOI_PREALLOC_BUFSZ */
+
+	curr_fsize = lseek(fd->fd_sys, 0, SEEK_END);
+	alloc_size = fcntl_struct->diskspace;
+
+	size = ADIOI_MIN(curr_fsize, alloc_size);
+	
+	ntimes = (size + ADIOI_PREALLOC_BUFSZ - 1)/ADIOI_PREALLOC_BUFSZ;
+	buf = (char *) ADIOI_Malloc(ADIOI_PREALLOC_BUFSZ);
+	done = 0;
+
+	for (i=0; i<ntimes; i++) {
+	    len = ADIOI_MIN(size-done, ADIOI_PREALLOC_BUFSZ);
+	    ADIO_ReadContig(fd, buf, len, MPI_BYTE, ADIO_EXPLICIT_OFFSET, done,
+			    &status, error_code);
+	    if (*error_code != MPI_SUCCESS) {
+		ADIOI_Free(buf);
+#ifdef MPICH2
+		*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		    "**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+		FPRINTF(stderr, "ADIOI_LUSTRE_Fcntl: To preallocate disk space, ROMIO needs to read the file and write it back, but is unable to read the file. Please give the file read permission and open it with MPI_MODE_RDWR.\n");
+		MPI_Abort(MPI_COMM_WORLD, 1);
+#else /* MPICH-1 */
+		*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_PREALLOC_PERM,
+			      myname, (char *) 0, (char *) 0);
+		ADIOI_Error(fd, *error_code, myname);
+#endif
+                return;  
+	    }
+	    ADIO_WriteContig(fd, buf, len, MPI_BYTE, ADIO_EXPLICIT_OFFSET, 
+                             done, &status, error_code);
+	    if (*error_code != MPI_SUCCESS) return;
+	    done += len;
+	}
+
+	if (alloc_size > curr_fsize) {
+	    memset(buf, 0, ADIOI_PREALLOC_BUFSZ); 
+	    size = alloc_size - curr_fsize;
+	    ntimes = (size + ADIOI_PREALLOC_BUFSZ - 1)/ADIOI_PREALLOC_BUFSZ;
+	    for (i=0; i<ntimes; i++) {
+		len = ADIOI_MIN(alloc_size-done, ADIOI_PREALLOC_BUFSZ);
+		ADIO_WriteContig(fd, buf, len, MPI_BYTE, ADIO_EXPLICIT_OFFSET, 
+				 done, &status, error_code);
+		if (*error_code != MPI_SUCCESS) return;
+		done += len;  
+	    }
+	}
+	ADIOI_Free(buf);
+	if (fd->fp_sys_posn != -1) 
+	    lseek(fd->fd_sys, fd->fp_sys_posn, SEEK_SET);
+	*error_code = MPI_SUCCESS;
+	break;
+
+    case ADIO_FCNTL_SET_IOMODE:
+        /* for implementing PFS I/O modes. will not occur in MPI-IO
+           implementation.*/
+	if (fd->iomode != fcntl_struct->iomode) {
+	    fd->iomode = fcntl_struct->iomode;
+	    MPI_Barrier(MPI_COMM_WORLD);
+	}
+	*error_code = MPI_SUCCESS;
+	break;
+
+    case ADIO_FCNTL_SET_ATOMICITY:
+	fd->atomicity = (fcntl_struct->atomicity == 0) ? 0 : 1;
+	*error_code = MPI_SUCCESS;
+	break;
+
+    default:
+	FPRINTF(stderr, "Unknown flag passed to ADIOI_LUSTRE_Fcntl\n");
+	MPI_Abort(MPI_COMM_WORLD, 1);
+    }
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_flush.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_flush.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_flush.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_flush.c	2005-12-06 11:54:37.903128261 -0500
@@ -0,0 +1,14 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_flush.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_Flush(ADIO_File fd, int *error_code)
+{
+    ADIOI_GEN_Flush(fd, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.h mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.h
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.h	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre.h	2005-12-06 11:54:37.891129861 -0500
@@ -0,0 +1,36 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre.h,v 1.2 2005/07/07 14:38:17 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#ifndef AD_UNIX_INCLUDE
+#define AD_UNIX_INCLUDE
+
+/* temp*/
+#define HAVE_ASM_TYPES_H 1
+
+#include <unistd.h>
+#include <linux/types.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include "lustre/lustre_user.h"
+#include "adio.h"
+
+#ifndef NO_AIO
+#ifdef AIO_SUN
+#include <sys/asynch.h>
+#else
+#include <aio.h>
+#ifdef NEEDS_ADIOCB_T
+typedef struct adiocb adiocb_t;
+#endif
+#endif
+#endif
+
+int ADIOI_LUSTRE_aio(ADIO_File fd, void *buf, int len, ADIO_Offset offset,
+		  int wr, void *handle);
+
+#endif
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_hints.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_hints.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_hints.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_hints.c	2005-12-06 11:54:37.904128127 -0500
@@ -0,0 +1,130 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_hints.c,v 1.2 2005/07/07 14:38:17 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_SetInfo(ADIO_File fd, MPI_Info users_info, int *error_code)
+{
+    char *value, *value_in_fd;
+    int flag, tmp_val, str_factor=-1, str_unit=0, start_iodev=-1;
+    struct lov_user_md lum = { 0 };
+    int err, myrank, fd_sys, perm, amode, old_mask;
+
+    if ( (fd->info) == MPI_INFO_NULL) {
+	/* This must be part of the open call. can set striping parameters 
+           if necessary. */ 
+	MPI_Info_create(&(fd->info));
+	
+	/* has user specified striping or server buffering parameters 
+           and do they have the same value on all processes? */
+	if (users_info != MPI_INFO_NULL) {
+	    value = (char *) ADIOI_Malloc((MPI_MAX_INFO_VAL+1)*sizeof(char));
+
+	    MPI_Info_get(users_info, "striping_factor", MPI_MAX_INFO_VAL, 
+			 value, &flag);
+	    if (flag) {
+		str_factor=atoi(value);
+		tmp_val = str_factor;
+		MPI_Bcast(&tmp_val, 1, MPI_INT, 0, fd->comm);
+		if (tmp_val != str_factor) {
+		    FPRINTF(stderr, "ADIOI_LUSTRE_SetInfo: the value for key \"striping_factor\" must be the same on all processes\n");
+		    MPI_Abort(MPI_COMM_WORLD, 1);
+		}
+	    }
+
+	    MPI_Info_get(users_info, "striping_unit", MPI_MAX_INFO_VAL, 
+			 value, &flag);
+	    if (flag) {
+		str_unit=atoi(value);
+		tmp_val = str_unit;
+		MPI_Bcast(&tmp_val, 1, MPI_INT, 0, fd->comm);
+		if (tmp_val != str_unit) {
+		    FPRINTF(stderr, "ADIOI_LUSTRE_SetInfo: the value for key \"striping_unit\" must be the same on all processes\n");
+		    MPI_Abort(MPI_COMM_WORLD, 1);
+		}
+	    }
+
+	    MPI_Info_get(users_info, "start_iodevice", MPI_MAX_INFO_VAL, 
+			 value, &flag);
+	    if (flag) {
+		start_iodev=atoi(value);
+		tmp_val = start_iodev;
+		MPI_Bcast(&tmp_val, 1, MPI_INT, 0, fd->comm);
+		if (tmp_val != start_iodev) {
+		    FPRINTF(stderr, "ADIOI_LUSTRE_SetInfo: the value for key \"start_iodevice\" must be the same on all processes\n");
+		    MPI_Abort(MPI_COMM_WORLD, 1);
+		}
+	    }
+
+         /* if user has specified striping info, process 0 tries to set it */
+	    if ((str_factor > 0) || (str_unit > 0) || (start_iodev >= 0)) {
+		MPI_Comm_rank(fd->comm, &myrank);
+		if (!myrank) {
+		    if (fd->perm == ADIO_PERM_NULL) {
+			old_mask = umask(022);
+			umask(old_mask);
+			perm = old_mask ^ 0666;
+		    }
+		    else perm = fd->perm;
+
+		    amode = 0;
+		    if (fd->access_mode & ADIO_CREATE)
+			amode = amode | O_CREAT;
+		    if (fd->access_mode & ADIO_RDWR ||
+			(fd->access_mode & ADIO_RDONLY &&
+			 fd->access_mode & ADIO_WRONLY))
+			amode = amode | O_RDWR;
+		    else if (fd->access_mode & ADIO_WRONLY)
+			amode = amode | O_WRONLY;
+		    else if (fd->access_mode & ADIO_RDONLY)
+			amode = amode | O_RDONLY;
+		    if (fd->access_mode & ADIO_EXCL)
+			amode = amode | O_EXCL;
+
+		    /* we need to create file so ensure this is set */
+                    amode = amode | O_LOV_DELAY_CREATE | O_CREAT;
+
+                    fd_sys = open(fd->filename, amode, perm);
+                    if (fd_sys == -1) { 
+		        if (errno != EEXIST) 
+			    FPRINTF(stderr, "ADIOI_LUSTRE_SetInfo: Failure to open file %s %d %d\n",strerror(errno), amode, perm);
+                    } else {
+                        lum.lmm_magic = LOV_USER_MAGIC;
+                        lum.lmm_pattern = 0;
+                        lum.lmm_stripe_size = str_unit;
+                        lum.lmm_stripe_count = str_factor;
+                        lum.lmm_stripe_offset = start_iodev;
+
+                        err = ioctl(fd_sys, LL_IOC_LOV_SETSTRIPE, &lum);
+                        if (err == -1 && errno != EEXIST) { 
+			    FPRINTF(stderr, "ADIOI_LUSTRE_SetInfo: Failure to set stripe info %s \n",strerror(errno));
+                        }
+
+                        close(fd_sys);
+                   }
+
+		}
+		MPI_Barrier(fd->comm);
+	    }
+
+	    ADIOI_Free(value);
+	}
+	
+	/* set the values for collective I/O and data sieving parameters */
+	ADIOI_GEN_SetInfo(fd, users_info, error_code);
+    }
+    
+    else {
+	/* The file has been opened previously and fd->fd_sys is a valid
+           file descriptor. cannot set striping parameters now. */
+	
+	/* set the values for collective I/O and data sieving parameters */
+	ADIOI_GEN_SetInfo(fd, users_info, error_code);
+
+    }
+    
+    *error_code = MPI_SUCCESS;
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iread.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iread.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iread.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iread.c	2005-12-06 11:54:37.904128127 -0500
@@ -0,0 +1,106 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_iread.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_IreadContig(ADIO_File fd, void *buf, int count, 
+                MPI_Datatype datatype, int file_ptr_type,
+                ADIO_Offset offset, ADIO_Request *request, int *error_code)  
+{
+    int len, typesize;
+#ifdef NO_AIO
+    ADIO_Status status;
+#else
+    int err=-1;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_IREADCONTIG";
+#endif
+#endif
+
+    (*request) = ADIOI_Malloc_request();
+    (*request)->optype = ADIOI_READ;
+    (*request)->fd = fd;
+    (*request)->datatype = datatype;
+
+    MPI_Type_size(datatype, &typesize);
+    len = count * typesize;
+
+#ifdef NO_AIO
+    /* HP, FreeBSD, Linux */
+    /* no support for nonblocking I/O. Use blocking I/O. */
+
+    ADIOI_LUSTRE_ReadContig(fd, buf, len, MPI_BYTE, file_ptr_type, offset, 
+			 &status, error_code);  
+    (*request)->queued = 0;
+#ifdef HAVE_STATUS_SET_BYTES
+    if (*error_code == MPI_SUCCESS) {
+	MPI_Get_elements(&status, MPI_BYTE, &len);
+	(*request)->nbytes = len;
+    }
+#endif
+
+#else
+    if (file_ptr_type == ADIO_INDIVIDUAL) offset = fd->fp_ind;
+    err = ADIOI_LUSTRE_aio(fd, buf, len, offset, 0, &((*request)->handle));
+    if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind += len;
+
+    (*request)->queued = 1;
+    ADIOI_Add_req_to_list(request);
+
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+	return;
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+#endif  /* NO_AIO */
+
+    fd->fp_sys_posn = -1;   /* set it to null. */
+    fd->async_count++;
+}
+
+
+
+void ADIOI_LUSTRE_IreadStrided(ADIO_File fd, void *buf, int count, 
+		       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Request *request, int
+                       *error_code)
+{
+    ADIO_Status status;
+#ifdef HAVE_STATUS_SET_BYTES
+    int typesize;
+#endif
+
+    *request = ADIOI_Malloc_request();
+    (*request)->optype = ADIOI_READ;
+    (*request)->fd = fd;
+    (*request)->datatype = datatype;
+    (*request)->queued = 0;
+    (*request)->handle = 0;
+
+/* call the blocking version. It is faster because it does data sieving. */
+    ADIOI_LUSTRE_ReadStrided(fd, buf, count, datatype, file_ptr_type, 
+                            offset, &status, error_code);  
+
+    fd->async_count++;
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if (*error_code == MPI_SUCCESS) {
+	MPI_Type_size(datatype, &typesize);
+	(*request)->nbytes = count * typesize;
+    }
+#endif
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iwrite.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iwrite.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iwrite.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_iwrite.c	2005-12-06 11:54:37.906127861 -0500
@@ -0,0 +1,268 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_iwrite.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_IwriteContig(ADIO_File fd, void *buf, int count, 
+                MPI_Datatype datatype, int file_ptr_type,
+                ADIO_Offset offset, ADIO_Request *request, int *error_code)  
+{
+    int len, typesize;
+#ifdef NO_AIO
+    ADIO_Status status;
+#else
+    int err=-1;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_IWRITECONTIG";
+#endif
+#endif
+
+    *request = ADIOI_Malloc_request();
+    (*request)->optype = ADIOI_WRITE;
+    (*request)->fd = fd;
+    (*request)->datatype = datatype;
+
+    MPI_Type_size(datatype, &typesize);
+    len = count * typesize;
+
+#ifdef NO_AIO
+    /* HP, FreeBSD, Linux */
+    /* no support for nonblocking I/O. Use blocking I/O. */
+
+    ADIOI_LUSTRE_WriteContig(fd, buf, len, MPI_BYTE, file_ptr_type, offset, 
+			  &status, error_code);  
+    (*request)->queued = 0;
+#ifdef HAVE_STATUS_SET_BYTES
+    if (*error_code == MPI_SUCCESS) {
+	MPI_Get_elements(&status, MPI_BYTE, &len);
+	(*request)->nbytes = len;
+    }
+#endif
+
+#else
+    if (file_ptr_type == ADIO_INDIVIDUAL) offset = fd->fp_ind;
+    err = ADIOI_LUSTRE_aio(fd, buf, len, offset, 1, &((*request)->handle));
+    if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind += len;
+
+    (*request)->queued = 1;
+    ADIOI_Add_req_to_list(request);
+
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+	return;
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+#endif /* NO_AIO */
+
+    fd->fp_sys_posn = -1;   /* set it to null. */
+    fd->async_count++;
+}
+
+
+
+
+void ADIOI_LUSTRE_IwriteStrided(ADIO_File fd, void *buf, int count, 
+		       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Request *request, int
+                       *error_code)
+{
+    ADIO_Status status;
+#ifdef HAVE_STATUS_SET_BYTES
+    int typesize;
+#endif
+
+    *request = ADIOI_Malloc_request();
+    (*request)->optype = ADIOI_WRITE;
+    (*request)->fd = fd;
+    (*request)->datatype = datatype;
+    (*request)->queued = 0;
+    (*request)->handle = 0;
+
+/* call the blocking version. It is faster because it does data sieving. */
+    ADIOI_LUSTRE_WriteStrided(fd, buf, count, datatype, file_ptr_type, 
+                            offset, &status, error_code);  
+
+    fd->async_count++;
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if (*error_code == MPI_SUCCESS) {
+	MPI_Type_size(datatype, &typesize);
+	(*request)->nbytes = count * typesize;
+    }
+#endif
+}
+
+
+/* This function is for implementation convenience. It is not user-visible.
+   It takes care of the differences in the interface for nonblocking I/O
+   on various Unix machines! If wr==1 write, wr==0 read. */
+
+int ADIOI_LUSTRE_aio(ADIO_File fd, void *buf, int len, ADIO_Offset offset,
+		  int wr, void *handle)
+{
+    int err=-1, fd_sys;
+
+#ifndef NO_AIO
+    int error_code;
+#ifdef AIO_SUN 
+    aio_result_t *result;
+#else
+    struct aiocb *aiocbp;
+#endif
+#endif
+
+    fd_sys = fd->fd_sys;
+
+#ifdef AIO_SUN
+    result = (aio_result_t *) ADIOI_Malloc(sizeof(aio_result_t));
+    result->aio_return = AIO_INPROGRESS;
+    if (wr) err = aiowrite(fd_sys, buf, len, offset, SEEK_SET, result); 
+    else err = aioread(fd_sys, buf, len, offset, SEEK_SET, result);
+
+    if (err == -1) {
+	if (errno == EAGAIN) { 
+       /* the man pages say EPROCLIM, but in reality errno is set to EAGAIN! */
+
+        /* exceeded the max. no. of outstanding requests.
+           complete all previous async. requests and try again.*/
+
+	    ADIOI_Complete_async(&error_code);
+	    if (wr) err = aiowrite(fd_sys, buf, len, offset, SEEK_SET, result); 
+	    else err = aioread(fd_sys, buf, len, offset, SEEK_SET, result);
+
+	    while (err == -1) {
+		if (errno == EAGAIN) {
+                    /* sleep and try again */
+                    sleep(1);
+		    if (wr) err = aiowrite(fd_sys, buf, len, offset, SEEK_SET, result); 
+		    else err = aioread(fd_sys, buf, len, offset, SEEK_SET, result);
+		}
+                else {
+                    FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+                    MPI_Abort(MPI_COMM_WORLD, 1);
+                }
+	    }
+	}
+        else {
+            FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+            MPI_Abort(MPI_COMM_WORLD, 1);
+        }
+    }
+
+    *((aio_result_t **) handle) = result;
+#endif
+
+#ifdef NO_FD_IN_AIOCB
+/* IBM */
+    aiocbp = (struct aiocb *) ADIOI_Malloc(sizeof(struct aiocb));
+    aiocbp->aio_whence = SEEK_SET;
+    aiocbp->aio_offset = offset;
+    aiocbp->aio_buf = buf;
+    aiocbp->aio_nbytes = len;
+    if (wr) err = aio_write(fd_sys, aiocbp);
+    else err = aio_read(fd_sys, aiocbp);
+
+    if (err == -1) {
+	if (errno == EAGAIN) {
+        /* exceeded the max. no. of outstanding requests.
+          complete all previous async. requests and try again. */
+
+	    ADIOI_Complete_async(&error_code);
+	    if (wr) err = aio_write(fd_sys, aiocbp);
+	    else err = aio_read(fd_sys, aiocbp);
+
+            while (err == -1) {
+                if (errno == EAGAIN) {
+                    /* sleep and try again */
+                    sleep(1);
+		    if (wr) err = aio_write(fd_sys, aiocbp);
+		    else err = aio_read(fd_sys, aiocbp);
+		}
+                else {
+                    FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+                    MPI_Abort(MPI_COMM_WORLD, 1);
+                }
+            }
+	}
+        else {
+            FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+            MPI_Abort(MPI_COMM_WORLD, 1);
+        }
+    }
+
+    *((struct aiocb **) handle) = aiocbp;
+
+#elif (!defined(NO_AIO) && !defined(AIO_SUN))
+/* DEC, SGI IRIX 5 and 6 */
+
+    aiocbp = (struct aiocb *) ADIOI_Calloc(sizeof(struct aiocb), 1);
+    aiocbp->aio_fildes = fd_sys;
+    aiocbp->aio_offset = offset;
+    aiocbp->aio_buf = buf;
+    aiocbp->aio_nbytes = len;
+
+#ifdef AIO_PRIORITY_DEFAULT
+/* DEC */
+    aiocbp->aio_reqprio = AIO_PRIO_DFL;   /* not needed in DEC Unix 4.0 */
+    aiocbp->aio_sigevent.sigev_signo = 0;
+#else
+    aiocbp->aio_reqprio = 0;
+#endif
+
+#ifdef AIO_SIGNOTIFY_NONE
+/* SGI IRIX 6 */
+    aiocbp->aio_sigevent.sigev_notify = SIGEV_NONE;
+#else
+    aiocbp->aio_sigevent.sigev_signo = 0;
+#endif
+
+    if (wr) err = aio_write(aiocbp);
+    else err = aio_read(aiocbp);
+
+    if (err == -1) {
+	if (errno == EAGAIN) {
+        /* exceeded the max. no. of outstanding requests.
+           complete all previous async. requests and try again. */
+
+	    ADIOI_Complete_async(&error_code);
+	    if (wr) err = aio_write(aiocbp);
+	    else err = aio_read(aiocbp);
+
+	    while (err == -1) {
+		if (errno == EAGAIN) {
+		    /* sleep and try again */
+		    sleep(1);
+		    if (wr) err = aio_write(aiocbp);
+		    else err = aio_read(aiocbp);
+		}
+		else {
+		    FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+		    MPI_Abort(MPI_COMM_WORLD, 1);
+		}
+	    }
+        }
+	else {
+	    FPRINTF(stderr, "Unknown errno %d in ADIOI_LUSTRE_aio\n", errno);
+	    MPI_Abort(MPI_COMM_WORLD, 1);
+	}
+    }
+
+    *((struct aiocb **) handle) = aiocbp;
+#endif
+
+    return err;
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_open.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_open.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_open.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_open.c	2005-12-06 11:54:37.906127861 -0500
@@ -0,0 +1,100 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_open.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_Open(ADIO_File fd, int *error_code)
+{
+    int perm, old_mask, amode;
+    struct lov_user_md lum = { 0 };
+    char *value;
+
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_OPEN";
+#endif
+
+    if (fd->perm == ADIO_PERM_NULL) {
+	old_mask = umask(022);
+	umask(old_mask);
+	perm = old_mask ^ 0666;
+    }
+    else perm = fd->perm;
+
+    amode = 0;
+    if (fd->access_mode & ADIO_CREATE)
+	amode = amode | O_CREAT;
+    if (fd->access_mode & ADIO_RDONLY)
+	amode = amode | O_RDONLY;
+    if (fd->access_mode & ADIO_WRONLY)
+	amode = amode | O_WRONLY;
+    if (fd->access_mode & ADIO_RDWR)
+	amode = amode | O_RDWR;
+    if (fd->access_mode & ADIO_EXCL)
+	amode = amode | O_EXCL;
+
+    fd->fd_sys = open(fd->filename, amode, perm);
+
+    if (fd->fd_sys != -1) {
+        int err;
+
+        value = (char *) ADIOI_Malloc((MPI_MAX_INFO_VAL+1)*sizeof(char));
+
+        /* get file striping information and set it in info */
+        lum.lmm_magic = LOV_USER_MAGIC;
+        err = ioctl(fd->fd_sys, LL_IOC_LOV_GETSTRIPE, (void *) &lum);
+
+        if (!err) {
+            sprintf(value, "%d", lum.lmm_stripe_size);
+            MPI_Info_set(fd->info, "striping_unit", value);
+
+            sprintf(value, "%d", lum.lmm_stripe_count);
+            MPI_Info_set(fd->info, "striping_factor", value);
+
+            sprintf(value, "%d", lum.lmm_stripe_offset);
+            MPI_Info_set(fd->info, "start_iodevice", value);
+        }
+        ADIOI_Free(value);
+
+        if (fd->access_mode & ADIO_APPEND)
+            fd->fp_ind = fd->fp_sys_posn = lseek(fd->fd_sys, 0, SEEK_END);
+    }
+
+
+    if ((fd->fd_sys != -1) && (fd->access_mode & ADIO_APPEND))
+	fd->fp_ind = fd->fp_sys_posn = lseek(fd->fd_sys, 0, SEEK_END);
+
+    if (fd->fd_sys == -1) {
+#ifdef MPICH2
+	if (errno == ENAMETOOLONG)
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_BAD_FILE, "**filenamelong", "**filenamelong %s %d", fd->filename, strlen(fd->filename) );
+	else if (errno == ENOENT)
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_NO_SUCH_FILE, "**filenoexist", "**filenoexist %s", fd->filename );
+	else if (errno == ENOTDIR || errno == ELOOP)
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_BAD_FILE, "**filenamedir", "**filenamedir %s", fd->filename );
+	else if (errno == EACCES) {
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ACCESS, "**fileaccess", "**fileaccess %s", 
+					       fd->filename );
+	}
+	else if (errno == EROFS) {
+	    /* Read only file or file system and write access requested */
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_READ_ONLY, "**ioneedrd", 0 );
+	}
+	else {
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+	}
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(ADIO_FILE_NULL, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_rdcoll.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_rdcoll.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_rdcoll.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_rdcoll.c	2005-12-06 11:54:37.907127727 -0500
@@ -0,0 +1,18 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_rdcoll.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_ReadStridedColl(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    ADIOI_GEN_ReadStridedColl(fd, buf, count, datatype, file_ptr_type,
+			      offset, status, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_read.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_read.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_read.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_read.c	2005-12-06 11:54:37.907127727 -0500
@@ -0,0 +1,67 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_read.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_ReadContig(ADIO_File fd, void *buf, int count, 
+                     MPI_Datatype datatype, int file_ptr_type,
+		     ADIO_Offset offset, ADIO_Status *status, int *error_code)
+{
+    int err=-1, datatype_size, len;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_READCONTIG";
+#endif
+
+    MPI_Type_size(datatype, &datatype_size);
+    len = datatype_size * count;
+
+    if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
+	if (fd->fp_sys_posn != offset) 
+	    lseek(fd->fd_sys, offset, SEEK_SET);
+	err = read(fd->fd_sys, buf, len);
+	fd->fp_sys_posn = offset + len;
+	/* individual file pointer not updated */        
+    }
+    else {  /* read from curr. location of ind. file pointer */
+	if (fd->fp_sys_posn != fd->fp_ind)
+	    lseek(fd->fd_sys, fd->fp_ind, SEEK_SET);
+	err = read(fd->fd_sys, buf, len);
+	fd->fp_ind += err; 
+	fd->fp_sys_posn = fd->fp_ind;
+    }         
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if (err != -1) MPIR_Status_set_bytes(status, datatype, err);
+#endif
+
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+}
+
+
+
+
+void ADIOI_LUSTRE_ReadStrided(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    ADIOI_GEN_ReadStrided(fd, buf, count, datatype, file_ptr_type,
+                        offset, status, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_resize.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_resize.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_resize.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_resize.c	2005-12-06 11:54:37.909127460 -0500
@@ -0,0 +1,32 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_resize.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_Resize(ADIO_File fd, ADIO_Offset size, int *error_code)
+{
+    int err;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_RESIZE";
+#endif
+    
+    err = ftruncate(fd->fd_sys, size);
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);	    
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_seek.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_seek.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_seek.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_seek.c	2005-12-06 11:54:37.911127194 -0500
@@ -0,0 +1,15 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_seek.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+ADIO_Offset ADIOI_LUSTRE_SeekIndividual(ADIO_File fd, ADIO_Offset offset, 
+		      int whence, int *error_code)
+{
+    return ADIOI_GEN_SeekIndividual(fd, offset, whence, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wait.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wait.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wait.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wait.c	2005-12-06 11:54:37.914126794 -0500
@@ -0,0 +1,188 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_wait.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_ReadComplete(ADIO_Request *request, ADIO_Status *status, int *error_code)  
+{
+#ifndef NO_AIO
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_READCOMPLETE";
+#endif
+#ifdef AIO_SUN 
+    aio_result_t *result=0, *tmp;
+#else
+    int err;
+#endif
+#ifdef AIO_HANDLE_IN_AIOCB
+    struct aiocb *tmp1;
+#endif
+#endif
+
+    if (*request == ADIO_REQUEST_NULL) {
+	*error_code = MPI_SUCCESS;
+	return;
+    }
+
+#ifdef AIO_SUN
+    if ((*request)->queued) {  /* dequeue it */
+	tmp = (aio_result_t *) (*request)->handle;
+	while (tmp->aio_return == AIO_INPROGRESS) usleep(1000); 
+	/* sleep for 1 ms., until done. Is 1 ms. a good number? */
+	/* when done, dequeue any one request */
+	result = (aio_result_t *) aiowait(0);
+
+        (*request)->nbytes = tmp->aio_return;
+
+	if (tmp->aio_return == -1) {
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		"**io %s", strerror(tmp->aio_errno));
+	    return;
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			  myname, "I/O Error", "%s", strerror(tmp->aio_errno));
+	    ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	}
+	else *error_code = MPI_SUCCESS;
+
+/* aiowait only dequeues a request. The completion of a request can be
+   checked by just checking the aio_return flag in the handle passed
+   to the original aioread()/aiowrite(). Therefore, I need to ensure
+   that aiowait() is called exactly once for each previous
+   aioread()/aiowrite(). This is also taken care of in ADIOI_xxxDone */
+    }
+    else *error_code = MPI_SUCCESS;
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if ((*request)->nbytes != -1)
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+
+#endif
+    
+#ifdef AIO_HANDLE_IN_AIOCB
+/* IBM */
+    if ((*request)->queued) {
+	do {
+	    err = aio_suspend(1, (struct aiocb **) &((*request)->handle));
+	} while ((err == -1) && (errno == EINTR));
+
+	tmp1 = (struct aiocb *) (*request)->handle;
+	if (err != -1) {
+	    err = aio_return(tmp1->aio_handle);
+	    (*request)->nbytes = err;
+	    errno = aio_error(tmp1->aio_handle);
+	}
+	else (*request)->nbytes = -1;
+
+/* on DEC, it is required to call aio_return to dequeue the request.
+   IBM man pages don't indicate what function to use for dequeue.
+   I'm assuming it is aio_return! POSIX says aio_return may be called 
+   only once on a given handle. */
+
+	if (err == -1) {
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		"**io %s", strerror(errno));
+	    return;
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+             myname, "I/O Error", "%s", strerror(errno));
+	    ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	}
+	else *error_code = MPI_SUCCESS;
+    } /* if ((*request)->queued)  */
+    else *error_code = MPI_SUCCESS;
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if ((*request)->nbytes != -1)
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+
+#elif (!defined(NO_AIO) && !defined(AIO_SUN))
+/* DEC, SGI IRIX 5 and 6 */
+    if ((*request)->queued) {
+	do {
+	    err = aio_suspend((const aiocb_t **) &((*request)->handle), 1, 0);
+	} while ((err == -1) && (errno == EINTR));
+
+	if (err != -1) {
+	    err = aio_return((struct aiocb *) (*request)->handle); 
+	    (*request)->nbytes = err;
+	    errno = aio_error((struct aiocb *) (*request)->handle);
+	}
+	else (*request)->nbytes = -1;
+
+	if (err == -1) {
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+		"**io %s", strerror(errno));
+	    return;
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else /* MPICH-1 */
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+	 	            myname, "I/O Error", "%s", strerror(errno));
+	    ADIOI_Error((*request)->fd, *error_code, myname);	    
+#endif
+	}
+	else *error_code = MPI_SUCCESS;
+    } /* if ((*request)->queued) */
+    else *error_code = MPI_SUCCESS;
+#ifdef HAVE_STATUS_SET_BYTES
+    if ((*request)->nbytes != -1)
+	MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+#endif
+
+#ifndef NO_AIO
+    if ((*request)->queued != -1) {
+
+	/* queued = -1 is an internal hack used when the request must
+	   be completed, but the request object should not be
+	   freed. This is used in ADIOI_Complete_async, because the user
+	   will call MPI_Wait later, which would require status to
+	   be filled. Ugly but works. queued = -1 should be used only
+	   in ADIOI_Complete_async. 
+           This should not affect the user in any way. */
+
+	/* if request is still queued in the system, it is also there
+           on ADIOI_Async_list. Delete it from there. */
+	if ((*request)->queued) ADIOI_Del_req_from_list(request);
+
+	(*request)->fd->async_count--;
+	if ((*request)->handle) ADIOI_Free((*request)->handle);
+	ADIOI_Free_request((ADIOI_Req_node *) (*request));
+	*request = ADIO_REQUEST_NULL;
+    }
+
+#else
+/* HP, FreeBSD, Linux */
+
+#ifdef HAVE_STATUS_SET_BYTES
+    MPIR_Status_set_bytes(status, (*request)->datatype, (*request)->nbytes);
+#endif
+    (*request)->fd->async_count--;
+    ADIOI_Free_request((ADIOI_Req_node *) (*request));
+    *request = ADIO_REQUEST_NULL;
+    *error_code = MPI_SUCCESS;
+#endif    
+}
+
+
+void ADIOI_LUSTRE_WriteComplete(ADIO_Request *request, ADIO_Status *status, int *error_code)  
+{
+    ADIOI_LUSTRE_ReadComplete(request, status, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wrcoll.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wrcoll.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wrcoll.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_wrcoll.c	2005-12-06 11:54:37.914126794 -0500
@@ -0,0 +1,18 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_wrcoll.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_WriteStridedColl(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    ADIOI_GEN_WriteStridedColl(fd, buf, count, datatype, file_ptr_type,
+			      offset, status, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_write.c mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_write.c
--- mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_write.c	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/ad_lustre_write.c	2005-12-06 11:54:37.914126794 -0500
@@ -0,0 +1,66 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_lustre_write.c,v 1.1.1.1 2004/11/04 11:03:38 liam Exp $    
+ *
+ *   Copyright (C) 1997 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "ad_lustre.h"
+
+void ADIOI_LUSTRE_WriteContig(ADIO_File fd, void *buf, int count, 
+                   MPI_Datatype datatype, int file_ptr_type,
+	           ADIO_Offset offset, ADIO_Status *status, int *error_code)
+{
+    int err=-1, datatype_size, len;
+#if defined(MPICH2) || !defined(PRINT_ERR_MSG)
+    static char myname[] = "ADIOI_LUSTRE_WRITECONTIG";
+#endif
+
+    MPI_Type_size(datatype, &datatype_size);
+    len = datatype_size * count;
+
+    if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
+	if (fd->fp_sys_posn != offset)
+	    lseek(fd->fd_sys, offset, SEEK_SET);
+	err = write(fd->fd_sys, buf, len);
+	fd->fp_sys_posn = offset + err;
+	/* individual file pointer not updated */        
+    }
+    else { /* write from curr. location of ind. file pointer */
+	if (fd->fp_sys_posn != fd->fp_ind)
+	    lseek(fd->fd_sys, fd->fp_ind, SEEK_SET);
+	err = write(fd->fd_sys, buf, len);
+	fd->fp_ind += err;
+	fd->fp_sys_posn = fd->fp_ind;
+    }
+
+#ifdef HAVE_STATUS_SET_BYTES
+    if (err != -1 && status) MPIR_Status_set_bytes(status, datatype, err);
+#endif
+
+    if (err == -1) {
+#ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
+	    "**io %s", strerror(errno));
+#elif defined(PRINT_ERR_MSG)
+			*error_code = MPI_ERR_UNKNOWN;
+#else
+	*error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR,
+			      myname, "I/O Error", "%s", strerror(errno));
+	ADIOI_Error(fd, *error_code, myname);
+#endif
+    }
+    else *error_code = MPI_SUCCESS;
+}
+
+
+
+void ADIOI_LUSTRE_WriteStrided(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    ADIOI_GEN_WriteStrided(fd, buf, count, datatype, file_ptr_type,
+                        offset, status, error_code);
+}
diff -r -u --new-file mpich-1.2.6/romio/adio/ad_lustre/Makefile.in mpich-1.2.6/romio/adio/ad_lustre/Makefile.in
--- mpich-1.2.6/romio/adio/ad_lustre/Makefile.in	1969-12-31 19:00:00.000000000 -0500
+++ mpich-1.2.6/romio/adio/ad_lustre/Makefile.in	2005-12-06 11:54:37.883130927 -0500
@@ -0,0 +1,47 @@
+CC          = @CC@
+AR          = @AR@
+LIBNAME     = @LIBNAME@
+srcdir      = @srcdir@
+CC_SHL      = @CC_SHL@
+SHLIBNAME   = @SHLIBNAME@
+
+INCLUDE_DIR = -I@MPI_INCLUDE_DIR@ -I${srcdir}/../include -I../include
+CFLAGS      = @CFLAGS@ $(INCLUDE_DIR)
+
+C_COMPILE_SHL = $(CC_SHL) @CFLAGS@ $(INCLUDE_DIR)
+
+@VPATH@
+
+AD_LUSTRE_OBJECTS = ad_lustre_close.o ad_lustre_read.o \
+      ad_lustre_open.o ad_lustre_write.o ad_lustre_done.o \
+      ad_lustre_fcntl.o ad_lustre_iread.o ad_lustre_iwrite.o ad_lustre_wait.o \
+      ad_lustre_resize.o ad_lustre_hints.o \
+      ad_lustre.o
+
+
+default: $(LIBNAME)
+	@if [ "@ENABLE_SHLIB@" != "none" ] ; then \
+	    $(MAKE) $(SHLIBNAME).la ;\
+	fi
+
+.SUFFIXES: $(SUFFIXES) .p .lo
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+.c.lo:
+	$(C_COMPILE_SHL) -c $<
+	@mv -f $*.o $*.lo
+
+$(LIBNAME): $(AD_LUSTRE_OBJECTS)
+	$(AR) $(LIBNAME) $(AD_LUSTRE_OBJECTS)
+
+AD_LUSTRE_LOOBJECTS=$(AD_LUSTRE_OBJECTS:.o=.lo)
+$(SHLIBNAME).la: $(AD_LUSTRE_LOOBJECTS)
+	$(AR) $(SHLIBNAME).la $(AD_LUSTRE_LOOBJECTS)
+
+coverage:
+	-@for file in  ${AD_LUSTRE_OBJECTS:.o=.c} ; do \
+		gcov -b -f $$file ; done
+
+clean:
+	@rm -f *.o *.lo
--- mpich-1.2.6/romio/Makefile.in	2004-01-27 18:27:35.000000000 -0500
+++ mpich-1.2.6/romio/Makefile.in	2005-12-06 11:54:38.000000000 -0500
@@ -14,7 +14,7 @@ DIRS        = mpi-io adio/common
 MPIO_DIRS   = mpi-io
 EXTRA_SRC_DIRS = @EXTRA_SRC_DIRS@
 FILE_SYS_DIRS = @FILE_SYS_DIRS@
-ALL_DIRS    = mpi-io mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran adio/common adio/ad_pfs adio/ad_piofs adio/ad_nfs adio/ad_ufs adio/ad_xfs adio/ad_hfs adio/ad_sfs adio/ad_testfs adio/ad_pvfs adio/ad_pvfs2 test
+ALL_DIRS    = mpi-io mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran adio/common adio/ad_pfs adio/ad_piofs adio/ad_nfs adio/ad_ufs adio/ad_xfs adio/ad_hfs adio/ad_sfs adio/ad_testfs adio/ad_pvfs adio/ad_pvfs2 adio/ad_lustre test
 SHELL       = /bin/sh
 
 @VPATH@
--- mpich-1.2.6/romio/configure.in	2004-08-02 09:37:31.000000000 -0400
+++ mpich-1.2.6/romio/configure.in	2005-12-06 11:54:38.000000000 -0500
@@ -90,7 +90,7 @@ MPIO_REQ_REAL_POBJECTS="_iotest.o _iowai
 #
 have_aio=no
 #
-known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
+known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs lustre"
 known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
 #
 # Defaults
@@ -1270,6 +1270,9 @@ fi
 if test -n "$file_system_testfs"; then
     AC_DEFINE(ROMIO_TESTFS,1,[Define for TESTFS])
 fi
+if test -n "$file_system_lustre"; then
+    AC_DEFINE(ROMIO_LUSTRE,1,[Define for LUSTRE])
+fi
 if test -n "$file_system_piofs"; then
     AC_DEFINE(PIOFS,1,[Define for PIOFS])
     USER_CFLAGS="$USER_CFLAGS -bI:/usr/include/piofs/piofs.exp"
@@ -1634,7 +1637,7 @@ AC_OUTPUT(Makefile localdefs mpi-io/Make
 		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
 		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
 		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
-		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
+		   adio/ad_testfs/Makefile adio/ad_lustre/Makefile adio/ad_pvfs/Makefile \
 		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
                    mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
                    mpi2-other/array/fortran/Makefile test/fmisc.f \
--- mpich-1.2.6/romio/configure	2004-08-04 12:08:28.000000000 -0400
+++ mpich-1.2.6/romio/configure	2005-12-06 11:54:38.000000000 -0500
@@ -623,7 +623,7 @@ MPIO_REQ_REAL_POBJECTS="_iotest.o _iowai
 #
 have_aio=no
 #
-known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
+known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs lustre xfs hfs sfs"
 known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
 #
 # Defaults
@@ -4022,6 +4022,13 @@ if test -n "$file_system_testfs"; then
 EOF
 
 fi
+if test -n "$file_system_lustre"; then
+    cat >> confdefs.h <<\EOF
+#define LUSTRE 1
+EOF
+
+fi
+
 if test -n "$file_system_piofs"; then
     cat >> confdefs.h <<\EOF
 #define PIOFS 1
@@ -4746,7 +4753,7 @@ trap 'rm -fr `echo "Makefile localdefs m
 		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
 		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
 		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
-		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
+		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile adio/ad_lustre/Makefile\
                    mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
                    mpi2-other/array/fortran/Makefile test/fmisc.f \
                    test/fcoll_test.f test/pfcoll_test.f test/fperf.f  adio/include/romioconf.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
@@ -4912,7 +4919,7 @@ CONFIG_FILES=\${CONFIG_FILES-"Makefile l
 		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
 		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
 		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
-		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
+		   adio/ad_testfs/Makefile adio/ad_lustre/Makefile adio/ad_pvfs/Makefile \
 		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
                    mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
                    mpi2-other/array/fortran/Makefile test/fmisc.f \
--- mpich-1.2.6/romio/adio/include/romioconf.h.in	2004-08-04 12:08:28.000000000 -0400
+++ mpich-1.2.6/romio/adio/include/romioconf.h.in	2005-12-06 11:54:38.000000000 -0500
@@ -192,6 +192,9 @@
 /* Define for TESTFS */
 #undef ROMIO_TESTFS
 
+/* Define for LUSTRE */
+#undef LUSTRE
+
 /* Define for PIOFS */
 #undef PIOFS
 
--- mpich-1.2.6/romio/adio/include/mpio_error.h	2002-11-15 11:26:23.000000000 -0500
+++ mpich-1.2.6/romio/adio/include/mpio_error.h	2005-12-06 11:54:38.000000000 -0500
@@ -62,6 +62,7 @@
 #define MPIR_ERR_FILETYPE 33 
 #define MPIR_ERR_NO_NTFS 35
 #define MPIR_ERR_NO_TESTFS 36
+#define MPIR_ERR_NO_LUSTRE 37
 
 /* MPI_ERR_COMM */
 #ifndef MPIR_ERR_COMM_NULL
--- mpich-1.2.6/romio/adio/include/adioi_fs_proto.h	2003-06-24 18:48:23.000000000 -0400
+++ mpich-1.2.6/romio/adio/include/adioi_fs_proto.h	2005-12-06 11:54:38.000000000 -0500
@@ -261,6 +261,68 @@ ADIO_Offset ADIOI_UFS_SeekIndividual(ADI
 void ADIOI_UFS_SetInfo(ADIO_File fd, MPI_Info users_info, int *error_code);
 #endif
 
+#ifdef LUSTRE
+extern struct ADIOI_Fns_struct ADIO_LUSTRE_operations;
+
+void ADIOI_LUSTRE_Open(ADIO_File fd, int *error_code);
+void ADIOI_LUSTRE_Close(ADIO_File fd, int *error_code);
+void ADIOI_LUSTRE_ReadContig(ADIO_File fd, void *buf, int count, 
+                      MPI_Datatype datatype, int file_ptr_type,
+                     ADIO_Offset offset, ADIO_Status *status, int
+		     *error_code);
+void ADIOI_LUSTRE_WriteContig(ADIO_File fd, void *buf, int count, 
+                      MPI_Datatype datatype, int file_ptr_type,
+                      ADIO_Offset offset, ADIO_Status *status, int
+		      *error_code);   
+void ADIOI_LUSTRE_IwriteContig(ADIO_File fd, void *buf, int count, 
+                      MPI_Datatype datatype, int file_ptr_type,
+                      ADIO_Offset offset, ADIO_Request *request, int
+		      *error_code);   
+void ADIOI_LUSTRE_IreadContig(ADIO_File fd, void *buf, int count, 
+                      MPI_Datatype datatype, int file_ptr_type,
+                      ADIO_Offset offset, ADIO_Request *request, int
+		      *error_code);   
+int ADIOI_LUSTRE_ReadDone(ADIO_Request *request, ADIO_Status *status, int
+		       *error_code);
+int ADIOI_LUSTRE_WriteDone(ADIO_Request *request, ADIO_Status *status, int
+		       *error_code);
+void ADIOI_LUSTRE_ReadComplete(ADIO_Request *request, ADIO_Status *status, int
+		       *error_code); 
+void ADIOI_LUSTRE_WriteComplete(ADIO_Request *request, ADIO_Status *status,
+			int *error_code); 
+void ADIOI_LUSTRE_Fcntl(ADIO_File fd, int flag, ADIO_Fcntl_t *fcntl_struct, int
+		*error_code); 
+void ADIOI_LUSTRE_WriteStrided(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Status *status, int
+		       *error_code);
+void ADIOI_LUSTRE_ReadStrided(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Status *status, int
+		       *error_code);
+void ADIOI_LUSTRE_WriteStridedColl(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Status *status, int
+		       *error_code);
+void ADIOI_LUSTRE_ReadStridedColl(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Status *status, int
+		       *error_code);
+void ADIOI_LUSTRE_IreadStrided(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Request *request, int
+		       *error_code);
+void ADIOI_LUSTRE_IwriteStrided(ADIO_File fd, void *buf, int count,
+		       MPI_Datatype datatype, int file_ptr_type,
+		       ADIO_Offset offset, ADIO_Request *request, int
+		       *error_code);
+void ADIOI_LUSTRE_Flush(ADIO_File fd, int *error_code);
+void ADIOI_LUSTRE_Resize(ADIO_File fd, ADIO_Offset size, int *error_code);
+ADIO_Offset ADIOI_LUSTRE_SeekIndividual(ADIO_File fd, ADIO_Offset offset, 
+                       int whence, int *error_code);
+void ADIOI_LUSTRE_SetInfo(ADIO_File fd, MPI_Info users_info, int *error_code);
+#endif
+
 #ifdef ROMIO_NTFS
 extern struct ADIOI_Fns_struct ADIO_NTFS_operations;
 
--- mpich-1.2.6/romio/adio/include/adio.h	2004-06-07 13:59:57.000000000 -0400
+++ mpich-1.2.6/romio/adio/include/adio.h	2005-12-06 11:54:38.000000000 -0500
@@ -276,6 +276,7 @@ typedef struct {
 #define ADIO_NTFS                158   /* NTFS for Windows NT */
 #define ADIO_TESTFS              159   /* fake file system for testing */
 #define ADIO_PVFS2               160   /* PVFS2: 2nd generation PVFS */
+#define ADIO_LUSTRE              161   /* Lustre */
 
 #define ADIO_SEEK_SET            SEEK_SET
 #define ADIO_SEEK_CUR            SEEK_CUR
--- mpich-1.2.6/romio/adio/common/setfn.c	2003-06-24 18:48:18.000000000 -0400
+++ mpich-1.2.6/romio/adio/common/setfn.c	2005-12-06 11:54:38.000000000 -0500
@@ -114,6 +114,16 @@ void ADIOI_SetFunctions(ADIO_File fd)
 #endif
 	break;
 
+    case ADIO_LUSTRE:
+#ifdef LUSTRE 
+        *(fd->fns) = ADIO_LUSTRE_operations;
+#else   
+        FPRINTF(stderr, "ADIOI_SetFunctions: ROMIO has not been configured to use the LUSTRE file system\n");
+        MPI_Abort(MPI_COMM_WORLD, 1);
+#endif 
+        break;
+
+
     default:
 	FPRINTF(stderr, "ADIOI_SetFunctions: Unsupported file system type\n");
         MPI_Abort(MPI_COMM_WORLD, 1);
--- mpich-1.2.6/romio/adio/common/ad_fstype.c	2003-09-04 16:24:44.000000000 -0400
+++ mpich-1.2.6/romio/adio/common/ad_fstype.c	2005-12-06 11:54:38.000000000 -0500
@@ -204,6 +204,11 @@ static void ADIO_FileSysType_fncall(char
 	}
     }
 #elif defined(LINUX)
+#warning use correct include
+# if defined (LUSTRE)
+#define LL_SUPER_MAGIC 0x0BD00BD0
+# endif
+
     do {
 	err = statfs(filename, &fsbuf);
     } while (err && (errno == ESTALE));
@@ -218,6 +223,9 @@ static void ADIO_FileSysType_fncall(char
     else {
 	/* FPRINTF(stderr, "%d\n", fsbuf.f_type);*/
 	if (fsbuf.f_type == NFS_SUPER_MAGIC) *fstype = ADIO_NFS;
+# if defined (LUSTRE)
+	else if (fsbuf.f_type == LL_SUPER_MAGIC) *fstype = ADIO_LUSTRE;
+#endif
 # if defined(ROMIO_PVFS)
 	else if (fsbuf.f_type == PVFS_SUPER_MAGIC) *fstype = ADIO_PVFS;
 # endif
@@ -359,6 +367,11 @@ static void ADIO_FileSysType_prefix(char
     {
 	*fstype = ADIO_TESTFS;
     }
+    else if (!strncmp(filename, "lustre:", 7) 
+	     || !strncmp(filename, "LUSTRE:", 7))
+    {
+	*fstype = ADIO_LUSTRE;
+    }
     else {
 #ifdef ROMIO_NTFS
 	*fstype = ADIO_NTFS;
@@ -644,6 +657,24 @@ void ADIO_ResolveFileType(MPI_Comm comm,
 	*ops = &ADIO_TESTFS_operations;
 #endif
     }
+    if (file_system == ADIO_LUSTRE) {
+#ifndef LUSTRE 
+# ifdef MPICH2
+	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**iofstypeunsupported", 0);
+	return;
+# elif defined(PRINT_ERR_MSG)
+	FPRINTF(stderr, "ADIO_ResolveFileType: ROMIO has not been configured to use the LUSTRE file system\n");
+	MPI_Abort(MPI_COMM_WORLD, 1);
+# else /* MPICH-1 */
+	myerrcode = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ERR_NO_LUSTRE,
+				     myname, (char *) 0, (char *) 0);
+	*error_code = ADIOI_Error(MPI_FILE_NULL, myerrcode, myname);
+# endif
+	return;
+#else
+	*ops = &ADIO_LUSTRE_operations;
+#endif
+    }
     *error_code = MPI_SUCCESS;
     *fstype = file_system;
     return;
